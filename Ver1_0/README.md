[1] Ver 1_0  
클라이언트 측 : rpicam8_streaming_cvjpeg.py  
서버 측 : 2_rpicam8_stream_flask.py 그리고 templates 폴더 안에 rpicam8.html  

- 연결 방식 설명
1. 클라이언트 측에서 picamera2를 이용하여 HD 화질의 영상으로 비디오를 설정한다.  
2. preview cam는 QT를 활용해 라즈베리파이 GUI 상에 띄운다.  
3. main cam은 TCP 방식으로 서버에 연결 작업을 한뒤 다음 작업을 반복한다.  

> capture_array()로 카메라의 프레임을 캡쳐한다.  
> 프레임을 cv2.imencode라는 OpenCV 함수를 이용하여 JPEG 방식으로 인코딩한다.  
> TCP 소켓을 통해 이미지 크기 및 이미지를 전송한다.  

4. 서버 측에서는 소캣 쓰레드를 분리하여 연결작업을 먼저 수행하고 다음 작업을 반복한다.  

> 프레임 크기 및 프레임을 수신 받는다.  
> 프레임을 디코딩하여 frame_data(전역변수)에 저장한다.  

5. 서버 측의 메인 쓰레드는 frame_data를 계속해서 video_feed 태그에 뿌린다. (Response로)  

- 문제점  
***잘 작동하지만 JPEG의 각 프레임을 따로따로 렌더링하는 무식한 방식이라 구현을 쉬울지언정 성능이 떨어지며, 실제 구동 시 프레임 드랍은 상당히 많이 일어난다. 720p30도 끊김.***  
(프레임 드랍, 실시간성 하락)  
1. TCP 대신 UDP를 이용한다.  
2. Picamera 자체에서 제공하는 H264Encoder를 이용하여 스트리밍하면 전송 용량을 크게 줄일 수 있으며, 라즈베리파이 자체에서 H.264 하드웨어 인코딩을 지원하기 때문에 성능이 더 좋다.
그러나 이 방법은 서버 측에서 디코딩 작업을 추가로 진행해야 하고 소캣 처리가 복잡할 수 있다.  
3. GStreamer가 최적화된 전송을 제공할 수 있다고 한다. (UDP 기반임)  

- 추후 구현 사항
1. H264 인코딩 후 전송 방식을 고려해볼 것  
2. 라즈베리파이 측에서 Qt GUI Framework를 이용하여, log를 띄워주거나 프레임(영상) 전송을 멈추고 시작할 수 있는 GUI 기능을 제공한다. -> 발표 시연 용도 포함  
