# Raspberry Pi
### 반드시 읽기를 권장합니다.
(라즈베리파이의 영상 스트리밍 코드와 모의 Flask 서버 코드 간 처리 코드)

[0] 기본 안내
- 클라이언트(라즈베리파이 : client 폴더), 서버(Flask : server 폴더) 측으로 구성되어 있습니다.
> ***클라이언트 코드는 같이 사용된 Picamera2 모듈이 Raspberry Pi OS에만 호환되므로 라즈베리파이 외에서는 실행할 수 없습니다. 이 경우 GUI 원격 접속하여야 합니다. (원격 접속 방법 아래 참고)***
- GUI 원격 접속 방법 (라즈베리파이는 24시간 구동 중이므로 항상 접속되어야 정상입니다.)
1. RealVNC Viewer를 설치.
2. 아래과 같이 공란에 IP주소:포트번호를 입력하세요.
(IP주소:포트번호는 저에게 요청하시기 바랍니다. 172.30.1.25는 아닙니다)
![image](https://github.com/user-attachments/assets/6fda43e0-82c1-4f63-8314-d8512dc71e3c)
3. 새로 뜨는 창에 라즈베리파이 내 아이디 및 비밀번호를 입력하세요.
(아이디 및 비밀번호도 저에게 요청하시기 바랍니다.)
4. 잘 접속되면, 아래와 같이 바탕화면이 뜹니다. 라즈베리파이 코드는 Visual Studio Code를 더블클릭하여 실행하면 담겨 있습니다. 파일명이 일치하는 소스코드를 실행하면 됩니다.
5. 한/영 전환 키는 Shift+Space입니다.
   
![image](https://github.com/user-attachments/assets/6645bafe-22bb-4003-9fb1-24d7edcc73fb)


<br>
<br>
<br>
<br>
<br>
<br>
<br>


[1] Ver 1_0  
클라이언트 측 : rpicam8_streaming_cvjpeg.py  
서버 측 : 2_rpicam8_stream_flask.py 그리고 templates 폴더 안에 rpicam8.html  

- 연결 방식 설명
1. 클라이언트 측에서 picamera2를 이용하여 HD 화질의 영상으로 비디오를 설정한다.  
2. preview cam는 QT를 활용해 라즈베리파이 GUI 상에 띄운다.  
3. main cam은 TCP 방식으로 서버에 연결 작업을 한뒤 다음 작업을 반복한다.  

> capture_array()로 카메라의 프레임을 캡쳐한다.  
> 프레임을 cv2.imencode라는 OpenCV 함수를 이용하여 JPEG 방식으로 인코딩한다.  
> TCP 소켓을 통해 이미지 크기 및 이미지를 전송한다.  

4. 서버 측에서는 소캣 쓰레드를 분리하여 연결작업을 먼저 수행하고 다음 작업을 반복한다.  

> 프레임 크기 및 프레임을 수신 받는다.  
> 프레임을 디코딩하여 frame_data(전역변수)에 저장한다.  

5. 서버 측의 메인 쓰레드는 frame_data를 계속해서 video_feed 태그에 뿌린다. (Response로)  

- 문제점  
***잘 작동하지만 JPEG의 각 프레임을 따로따로 렌더링하는 무식한 방식이라 구현을 쉬울지언정 성능이 떨어지며, 실제 구동 시 프레임 드랍은 상당히 많이 일어난다. 720p30도 끊김.***  
(프레임 드랍, 실시간성 하락)  
1. TCP 대신 UDP를 이용한다.  
2. Picamera 자체에서 제공하는 H264Encoder를 이용하여 스트리밍하면 전송 용량을 크게 줄일 수 있으며, 라즈베리파이 자체에서 H.264 하드웨어 인코딩을 지원하기 때문에 성능이 더 좋다.
그러나 이 방법은 서버 측에서 디코딩 작업을 추가로 진행해야 하고 소캣 처리가 복잡할 수 있다.  
3. GStreamer가 최적화된 전송을 제공할 수 있다고 한다. (UDP 기반임)  

- 추후 구현 사항
1. H264 인코딩 후 전송 방식을 고려해볼 것  
2. 라즈베리파이 측에서 Qt GUI Framework를 이용하여, log를 띄워주거나 프레임(영상) 전송을 멈추고 시작할 수 있는 GUI 기능을 제공한다. -> 발표 시연 용도 포함  
 
